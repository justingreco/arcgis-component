import { r, t as t$1, h as e } from './cast-3d5be210.js';
import { r as r$2, M, h as h$2, f as f$1 } from './mat3-eb8de168.js';
import { M as e$2 } from './DefaultUI-a0db5719.js';
import { I } from './enums-33a95ace.js';
import { c as c$2, f } from './FramebufferObject-bfb23fd2.js';
import { F } from './enums-4770f29d.js';
import { e as e$1 } from './config-5446e136.js';
import { r as r$1 } from './TiledDisplayObject-2082c8d9.js';

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
class t{constructor(t){this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=t;}}class s$1{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1;}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
class s{constructor(t){this.tile=t,this.parent=null,this.children=new Set;}}class i{constructor(){this.nodes=new Map,this.roots=new Set;}create(t){const e=new s(t);let r;const i=[];if(this.nodes.forEach((t=>{this._canConnectDirectly(e,t)&&i.push(t),!r&&this._canConnectDirectly(t,e)&&(r=t);})),r){for(const t of i)r.children.delete(t),e.children.add(t),t.parent=e;r.children.add(e),e.parent=r;}else {this.roots.add(e);for(const t of i)e.children.add(t),t.parent=e,this.roots.delete(t);}return this.nodes.set(t.key.id,e),e}destroy(e){r(e.parent)?(e.parent.children.delete(e),e.children.forEach((r$1=>{r(e.parent)&&e.parent.children.add(r$1);}))):this.roots.delete(e),e.children.forEach((t=>{t.parent=e.parent,e.parent||this.roots.add(t);})),this.nodes.delete(e.tile.key.id);}clear(){this.roots.clear(),this.nodes.clear();}_canConnectDirectly(t,e){let{level:r,row:s,col:i}=e.tile.key;const{world:l}=e.tile.key;for(;r>0;){if(r--,s>>=1,i>>=1,t.tile.key.level===r&&t.tile.key.row===s&&t.tile.key.col===i&&t.tile.key.world===l)return !0;if(this.nodes.has(`${r}/${s}/${i}/${l}`))return !1}return !1}}class l$1{constructor(){this._tileGraph=new i,this._tileArray=null;}has(t){return "string"==typeof t?this._tileGraph.nodes.has(t):this._tileGraph.nodes.has(t.key.id)}getAll(){return this._tileArray||(this._tileArray=[],this._tileGraph.nodes.forEach((t=>{this._tileArray.push(t.tile);}))),this._tileArray}getRoots(){const t=[];return this._tileGraph.roots.forEach((e=>{t.push(e.tile);})),t}getParent(e){const r$1=this._tileGraph.nodes.get("string"==typeof e?e:e.key.id);return r(r$1.parent)&&r$1.parent.tile}getChildren(t){const e=[];return this._tileGraph.nodes.get("string"==typeof t?t:t.key.id).children.forEach((t=>{e.push(t.tile);})),e}get(t){return this._tileGraph.nodes.get(t).tile}removeKey(t){const e=this._tileGraph.nodes.get(t);this._tileGraph.destroy(e),this._tileArray=null;}forEach(t){this._tileGraph.nodes.forEach(((e,r)=>t(e.tile,r)));}add(t){this._tileGraph.create(t),this._tileArray=null;}remove(t){const e=this._tileGraph.nodes.get(t.key.id);this._tileGraph.destroy(e),this._tileArray=null;}clear(){this._tileGraph.clear(),this._tileArray=[];}}function o(t,e,r,s,i,l){const o=r-i;if(o>=0)return (e>>o)+(s-(l<<o))*(t>>o);const n=-o;return e-(l-(s<<n))*(t>>n)<<n}class n{constructor(t,e,r){this._rows=Math.ceil(e/r),this._columns=Math.ceil(t/r),this._cellSize=r,this.cells=new Array(this._rows);for(let s=0;s<this._rows;s++){this.cells[s]=new Array(this._columns);for(let t=0;t<this._columns;t++)this.cells[s][t]=[];}}getCell(t,e){const r=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),s=Math.min(Math.max(Math.floor(t/this._cellSize),0),this._columns-1);return this.cells[r]&&this.cells[r][s]||null}getCellSpan(t,e,r,s){return [Math.min(Math.max(Math.floor(t/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(r/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}}function h$1(t$1,e,s,i,l,o){const n=e[i++];for(let h=0;h<n;h++){const n=new t(o);n.xTile=e[i++],n.yTile=e[i++],n.hash=e[i++],n.priority=e[i++];const h=e[i++];for(let t=0;t<h;t++){const t=e[i++],r=e[i++],l=e[i++],o=e[i++],h=!!e[i++],a=e[i++],c=s[i++],d=s[i++],p=e[i++],u=e[i++];n.colliders.push({xTile:t,yTile:r,dxPixels:l,dyPixels:o,hard:h,partIndex:a,width:p,height:u,minLod:c,maxLod:d});}const a=t$1[i++];for(let e=0;e<a;e++)n.textVertexRanges.push([t$1[i++],t$1[i++]]);const c=t$1[i++];for(let e=0;e<c;e++)n.iconVertexRanges.push([t$1[i++],t$1[i++]]);l.push(n);}return i}function a$1(t,e,r){for(const[s,i]of t.symbols)c$1(t,e,r,i,s);}function c$1(t,r,s,i,l){const o=t.layerData.get(l);if(o.type===I.SYMBOL){for(const e of i){const r=e.unique;let i;if(e.selectedForRendering){const e=r.parts[0],l=e.startOpacity,o=e.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===o;const n=s?Math.floor(127*l)|o<<7:o?255:0;i=n<<24|n<<16|n<<8|n;}else i=0;for(const[t,s]of e.iconVertexRanges)for(let e=t;e<t+s;e+=4)o.iconOpacity[e/4]=i;if(e.selectedForRendering){const e=r.parts[1],l=e.startOpacity,o=e.targetOpacity;t.allSymbolsFadingOut=t.allSymbolsFadingOut&&0===o;const n=s?Math.floor(127*l)|o<<7:o?255:0;i=n<<24|n<<16|n<<8|n;}else i=0;for(const[t,s]of e.textVertexRanges)for(let e=t;e<t+s;e+=4)o.textOpacity[e/4]=i;}o.lastOpacityUpdate=r,o.opacityChanged=!0;}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
class a{constructor(e,t){this.layerUIDs=[],this.isDestroyed=!1,this.data=e,this.memoryUsed=e.byteLength;let r=1;const i=new Uint32Array(e);this.layerUIDs=[];const s=i[r++];for(let n=0;n<s;n++)this.layerUIDs[n]=i[r++];this.bufferDataOffset=r,t&&(this.layer=t.getStyleLayerByUID(this.layerUIDs[0]));}get isPreparedForRendering(){return t$1(this.data)}get offset(){return this.bufferDataOffset}destroy(){this.isDestroyed||(this.doDestroy(),this.isDestroyed=!0);}prepareForRendering(t){t$1(this.data)||(this.doPrepareForRendering(t,this.data,this.bufferDataOffset),this.data=null);}}class l extends a{constructor(e,t){super(e,t),this.type=I.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.lineIndexStart=r[s++],this.lineIndexCount=r[s++];const n=r[s++];if(n>0){const e=new Map;for(let t=0;t<n;t++){const t=r[s++],i=r[s++],n=r[s++];e.set(t,[i,n]);}this.patternMap=e;}this.bufferDataOffset=s;}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){r(this.lineVertexArrayObject)&&this.lineVertexArrayObject.dispose(),r(this.lineVertexBuffer)&&this.lineVertexBuffer.dispose(),r(this.lineIndexBuffer)&&this.lineIndexBuffer.dispose(),this.lineVertexArrayObject=null,this.lineVertexBuffer=null,this.lineIndexBuffer=null,this.memoryUsed=0;}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.lineVertexBuffer=c$2.createVertex(e,F.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.lineIndexBuffer=c$2.createIndex(e,F.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=this.layer.lineMaterial;this.lineVertexArrayObject=new f(e,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:this.lineVertexBuffer},this.lineIndexBuffer);}}class u$1 extends a{constructor(e,t){super(e,t),this.type=I.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.fillIndexStart=r[s++],this.fillIndexCount=r[s++],this.outlineIndexStart=r[s++],this.outlineIndexCount=r[s++];const n=r[s++];if(n>0){const e=new Map;for(let t=0;t<n;t++){const t=r[s++],i=r[s++],n=r[s++];e.set(t,[i,n]);}this.patternMap=e;}this.bufferDataOffset=s;}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return (this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){r(this.fillVertexArrayObject)&&this.fillVertexArrayObject.dispose(),r(this.fillVertexBuffer)&&this.fillVertexBuffer.dispose(),r(this.fillIndexBuffer)&&this.fillIndexBuffer.dispose(),this.fillVertexArrayObject=null,this.fillVertexBuffer=null,this.fillIndexBuffer=null,r(this.outlineVertexArrayObject)&&this.outlineVertexArrayObject.dispose(),r(this.outlineVertexBuffer)&&this.outlineVertexBuffer.dispose(),r(this.outlineIndexBuffer)&&this.outlineIndexBuffer.dispose(),this.outlineVertexArrayObject=null,this.outlineVertexBuffer=null,this.outlineIndexBuffer=null,this.memoryUsed=0;}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.fillVertexBuffer=c$2.createVertex(e,F.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.fillIndexBuffer=c$2.createIndex(e,F.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=i[r++];this.outlineVertexBuffer=c$2.createVertex(e,F.STATIC_DRAW,new Int32Array(s.buffer,4*r,u)),r+=u;const h=i[r++];this.outlineIndexBuffer=c$2.createIndex(e,F.STATIC_DRAW,new Uint32Array(i.buffer,4*r,h)),r+=h;const c=this.layer,x=c.fillMaterial,y=c.outlineMaterial;this.fillVertexArrayObject=new f(e,x.getAttributeLocations(),x.getLayoutInfo(),{geometry:this.fillVertexBuffer},this.fillIndexBuffer),this.outlineVertexArrayObject=new f(e,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.outlineVertexBuffer},this.outlineIndexBuffer);}}class h extends a{constructor(e,t,r){super(e,t),this.type=I.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const n=new Uint32Array(e),f=new Int32Array(e),o=new Float32Array(e);let a=this.bufferDataOffset;this.isIconSDF=!!n[a++];const l=n[a++];for(let i=0;i<l;i++){const e=n[a++],t=n[a++],r=n[a++];this.iconPerPageElementsMap.set(e,[t,r]);}const u=n[a++];for(let i=0;i<u;i++){const e=n[a++],t=n[a++],r=n[a++];this.glyphPerPageElementsMap.set(e,[t,r]);}const h=n[a++],c=n[a++];this.iconOpacity=new Int32Array(h),this.textOpacity=new Int32Array(c),a=h$1(n,f,o,a,this.symbols,r),this.bufferDataOffset=a;}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const[t,r]of this.iconPerPageElementsMap)e+=r[1];for(const[t,r]of this.glyphPerPageElementsMap)e+=r[1];return e/3}doDestroy(){r(this.iconVertexArrayObject)&&this.iconVertexArrayObject.dispose(),r(this.iconVertexBuffer)&&this.iconVertexBuffer.dispose(),r(this.iconOpacityBuffer)&&this.iconOpacityBuffer.dispose(),r(this.iconIndexBuffer)&&this.iconIndexBuffer.dispose(),this.iconVertexArrayObject=null,this.iconVertexBuffer=null,this.iconOpacityBuffer=null,this.iconIndexBuffer=null,r(this.textVertexArrayObject)&&this.textVertexArrayObject.dispose(),r(this.textVertexBuffer)&&this.textVertexBuffer.dispose(),r(this.textOpacityBuffer)&&this.textOpacityBuffer.dispose(),r(this.textIndexBuffer)&&this.textIndexBuffer.dispose(),this.textVertexArrayObject=null,this.textVertexBuffer=null,this.textOpacityBuffer=null,this.textIndexBuffer=null,this.memoryUsed=0;}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e$1=e(this.iconOpacity),t=e(this.iconOpacityBuffer);e$1.length>0&&e$1.byteLength===t.size&&t.setSubData(e$1);const i=e(this.textOpacity),s=e(this.textOpacityBuffer);i.length>0&&i.byteLength===s.size&&s.setSubData(i);}doPrepareForRendering(e$1,t,i){const s=new Uint32Array(t),a=new Int32Array(s.buffer),l=s[i++];this.iconVertexBuffer=c$2.createVertex(e$1,F.STATIC_DRAW,new Int32Array(a.buffer,4*i,l)),i+=l;const u=s[i++];this.iconIndexBuffer=c$2.createIndex(e$1,F.STATIC_DRAW,new Uint32Array(s.buffer,4*i,u)),i+=u;const h=s[i++];this.textVertexBuffer=c$2.createVertex(e$1,F.STATIC_DRAW,new Int32Array(a.buffer,4*i,h)),i+=h;const c=s[i++];this.textIndexBuffer=c$2.createIndex(e$1,F.STATIC_DRAW,new Uint32Array(s.buffer,4*i,c)),i+=c,this.iconOpacityBuffer=c$2.createVertex(e$1,F.STATIC_DRAW,e(this.iconOpacity).buffer),this.textOpacityBuffer=c$2.createVertex(e$1,F.STATIC_DRAW,e(this.textOpacity).buffer);const x=this.layer,y=x.iconMaterial,d=x.textMaterial;this.iconVertexArrayObject=new f(e$1,y.getAttributeLocations(),y.getLayoutInfo(),{geometry:this.iconVertexBuffer,opacity:this.iconOpacityBuffer},this.iconIndexBuffer),this.textVertexArrayObject=new f(e$1,d.getAttributeLocations(),d.getLayoutInfo(),{geometry:this.textVertexBuffer,opacity:this.textOpacityBuffer},this.textIndexBuffer);}}class c extends a{constructor(e,t){super(e,t),this.type=I.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const r=new Uint32Array(e);let s=this.bufferDataOffset;this.circleIndexStart=r[s++],this.circleIndexCount=r[s++],this.bufferDataOffset=s;}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){r(this.circleVertexArrayObject)&&this.circleVertexArrayObject.dispose(),r(this.circleVertexBuffer)&&this.circleVertexBuffer.dispose(),r(this.circleIndexBuffer)&&this.circleIndexBuffer.dispose(),this.circleVertexArrayObject=null,this.circleVertexBuffer=null,this.circleIndexBuffer=null,this.memoryUsed=0;}doPrepareForRendering(e,t,r){const i=new Uint32Array(t),s=new Int32Array(i.buffer),a=i[r++];this.circleVertexBuffer=c$2.createVertex(e,F.STATIC_DRAW,new Int32Array(s.buffer,4*r,a)),r+=a;const l=i[r++];this.circleIndexBuffer=c$2.createIndex(e,F.STATIC_DRAW,new Uint32Array(i.buffer,4*r,l)),r+=l;const u=this.layer.circleMaterial;this.circleVertexArrayObject=new f(e,u.getAttributeLocations(),u.getLayoutInfo(),{geometry:this.circleVertexBuffer},this.circleIndexBuffer);}}

/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.24/esri/copyright.txt for details.
*/
class m extends r$1{constructor(e,t,s,a,r,i,o=null){super(e,t,s,a,r,4096,4096),this._memCache=o,this.type="vector-tile",this._referenced=0,this._hasSymbolBuckets=!1,this._memoryUsedByLayerData=0,this.layerData=new Map,this.layerCount=0,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.invalidating=!1,this.parentTile=null,this.childrenTiles=new Set,this._processed=!1,this._referenced=1,this.styleRepository=i,this.id=e.id;}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<e$1}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<e$1)}get wasRequested(){return "errored"===this.status||"loaded"===this.status||"reloading"===this.status}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this.invalidating=!1,this._processed=!0;}deleteLayerData(t){let s=!1;for(const e of t)if(this.layerData.has(e)){const t=this.layerData.get(e);this._memoryUsedByLayerData-=t.memoryUsed,t.type===I.SYMBOL&&this.symbols.has(e)&&(this.symbols.delete(e),s=!0),t.destroy(),this.layerData.delete(e),this.layerCount--;}r(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData),s&&this.emit("symbols-changed"),this.requestRender();}processed(){return this._processed}hasData(){return this.layerCount>0}dispose(){"unloaded"!==this.status&&(u.delete(this),m._destroyRenderBuckets(this.layerData),this.layerData=null,this.layerCount=0,this._memoryUsedByLayerData=0,this.destroy(),this.status="unloaded");}release(){return 0==--this._referenced&&(this.dispose(),this.stage=null,!0)}retain(){++this._referenced;}get referenced(){return this._referenced}get memoryUsage(){return (this._memoryUsedByLayerData+256)/(this._referenced||1)}changeDataImpl(t){let s=!1;if(t){const{bucketsWithData:a,emptyBuckets:r$1}=t,i=this._createRenderBuckets(a);if(r$1&&r$1.byteLength>0){const e=new Uint32Array(r$1);for(const t of e)this._deleteLayerData(t);}for(const[e,t]of i)this._deleteLayerData(e),t.type===I.SYMBOL&&(this.symbols.set(e,t.symbols),s=!0),this._memoryUsedByLayerData+=t.memoryUsed,this.layerData.set(e,t),this.layerCount++;r(this._memCache)&&this._memCache.updateSize(this.key.id,this,this._memoryUsedByLayerData);}this._hasSymbolBuckets=!1;for(const[e,a]of this.layerData)a.type===I.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed");}attachWithContext(e){this.stage={context:e,trashDisplayObject(e){e.processDetach();},untrashDisplayObject:()=>!1};}setTransform(e,i){super.setTransform(e,i);const o=i/(e.resolution*e.pixelRatio),h=this.width/this.rangeX*o,n=this.height/this.rangeY*o,l=[0,0];e.toScreen(l,[this.x,this.y]);const y=this.transforms.tileUnitsToPixels;r$2(y),M(y,y,l),h$2(y,y,Math.PI*e.rotation/180),f$1(y,y,[h,n,1]);}_createTransforms(){return {dvs:e$2(),tileMat3:e$2(),tileUnitsToPixels:e$2()}}static _destroyRenderBuckets(e){if(!e)return;const t=new Set;e.forEach((e=>{t.has(e)||(e.destroy(),t.add(e));})),e.clear();}_createRenderBuckets(e){const t=new Map,s=new Map;for(const a of e){const e=this._deserializeBucket(a,s);for(const s of e.layerUIDs)t.set(s,e);}return t}_deserializeBucket(e,t){let s=t.get(e);if(s)return s;switch(new Uint32Array(e)[0]){case I.FILL:s=new u$1(e,this.styleRepository);break;case I.LINE:s=new l(e,this.styleRepository);break;case I.SYMBOL:s=new h(e,this.styleRepository,this);break;case I.CIRCLE:s=new c(e,this.styleRepository);}return t.set(e,s),s}_deleteLayerData(e){if(!this.layerData.has(e))return;const t=this.layerData.get(e);this._memoryUsedByLayerData-=t.memoryUsed,t.destroy(),this.layerData.delete(e),this.layerCount--;}}const u=new Map;function p(){u.forEach(((e,t)=>{console.log(`\n${t.key}:`),e[0].forEach((e=>console.log(e))),console.log("========"),e[1].forEach((e=>console.log(e)));}));}

export { a$1 as a, m, n, o, p, s$1 as s };
